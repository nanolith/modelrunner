\section{Literate Unit Testing}

The first challenge we encounter when writing a modern literate application is
finding a way to incorporate unit tests into the narrative. Minweb has a
facility for capturing test values, running these values through a test
framework, and pulling the outputs back into the literate document.  We will
make use of these.  However, we need to develop a way to read these test values,
input them into unit tests, and capture the output.  We don't want to go through
a bunch of manual setup for each test, as this would detract from the narrative.
So, as much as possible, we want to automate this marshalling process so we can
focus just on the unit tests themselves. Ideally, we want to write these tests
in the same language that we use for other parts of the application.  In this
case, we are using modern C for the application.  Thus, we will use C for the
tests.

Before we get into the design and implementation of marshalling facilities,
let's start by defining our unit test runner.

\subsection{Unit Test Runner}

The unit test runner iterates through an array of unit test suites, each of
which are arrays of unit test cases.  Unit test cases are functions taking no
parameters and returning a Boolean value. If the function returns \verb/true/,
then the test passes. If the function returns \verb/false/, then the test fails.
To provide reporting to the user, the array actually contains two items: the
name of the test and the test function pointer. In order to simplify test
registration, we will provide a simple macro that expands to both of these items
when given the name of a test.

Let's start with the test header.  This header will start with the definition of
our unit test function type.  Then, it will declare the structure that we use
for holding unit test cases.

#[language=c]
<<FILE:include/modelrunner/test.h>>=
<<header-prologue>>

#include <rcpr/allocator.h>
#include <rcpr/compare.h>
#include <rcpr/rbtree.h>
#include <rcpr/resource.h>
#include <rcpr/resource/protected.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>

typedef bool (*unit_test_function)();

typedef struct unit_test_case unit_test_case;
struct unit_test_case
{
    const char* name;
    unit_test_function function;
};
>>@<<

The \verb/unit_test_function/ type defines a function pointer that takes no
arguments and returns a Boolean (\verb/bool/) value indicating whether the test
passed (\verb/true/) or the test failed (\verb/false/). The
\verb/unit_test_case/ type is a structure containing the name of the unit test
and the function to call to run this unit test.

Next, we define the \verb/unit_test_suite/ type that we use for defining test
suites.

#[language=c]
<<FILE:include/modelrunner/test.h>>=
typedef struct unit_test_suite unit_test_suite;
struct unit_test_suite
{
    const char* name;
    unit_test_case* array;
    size_t entries;
};
>>@<<

\newpage

The \verb/unit_test_suite/ has a name, an array, and a number of entries in the
suite. Now, we can create some helper macros that will make life easier for
defining test suites and test cases. The first macro, \verb/TEST_SUITE/, will
expand to the name of the test suite, the test suite array, and the number of
entries in the test suite. The \verb/TEST_SUITE_DECL/ macro provides us a helper
for declaring the test suite array.

#[language=c]
<<FILE:include/modelrunner/test.h>>=
#define TEST_SUITE(suite) \
    { .name = #suite, .array = suite ## _array, \
      .entries = sizeof( suite ## _array ) / sizeof(unit_test_case) },
#define TEST_SUITE_DECL(suite) \
    extern unit_test_case suite ## _array [];
>>@<<

This expands the provided suite to a string representation of its name, then an
array reference, and then a computed size of this array.  We'll see in a moment
how the test runner can use this information. We also define a
\verb/TEST_SUITE_BEGIN/ macro and a \verb/TEST_SUITE_END/ macro to automate the
creation of an array for holding test cases in a test suite.

#[language=c]
<<FILE:include/modelrunner/test.h>>=
#define TEST_SUITE_BEGIN(suite) \
    unit_test_case suite ## _array [] = \
    {
#define TEST_SUITE_END() };
>>@<<

We make a similar expansion as \verb/TEST_SUITE/ for \verb/TEST/. Likewise, the
\verb/TEST_DECL/ provides us with a way to declare the unit test function.

#[language=c]
<<FILE:include/modelrunner/test.h>>=
#define TEST(testcase) \
    { .name = # testcase, .function=& testcase },
#define TEST_DECL(testcase) \
    bool testcase();
>>@<<

In this expansion, we expand the test case to a string for its name, and then
take the address of the test case to get a function pointer, which is assigned
to the function part of this definition. We can combine all of this to set up a
test runner, but first, let's complete the test header.  We will reference a
\verb/marshalling-header/ and provide the header epilogue.  The
\verb/marshalling-header/ is a place holder for the marshalling functionality
that we will add in the next subsection.

#[language=c]
<<FILE:include/modelrunner/test.h>>=
<<marshalling-header>>
<<header-epilogue>>
>>@<<

The unit test runner includes the \verb/main/ entry point for our unit tests. It
iterates through each test suite, and then iterates through each unit test in
each suite. For each unit test, it runs the test. If it passes, it emits a dot.
If it fails, it emits an exclamation point and the name of the failing test.

#[language=c]
<<FILE:test/test_runner.c>>=
#include <modelrunner/test.h>
#include <stdio.h>

<<test-suite-definition>>
<<test-runner-helpers>>
<<test-runner-main>>
>>@<<

\newpage

The first thing we do with the test runner is pull in the \verb/test-suites/
macro.  More on this in a moment.

Next, we define a \verb/main/ entry point that sets up the test suite. The main
entry point computes some initial tallies, then runs all of the tests.

#[language=c]
<<test-runner-main>>=
int main(int argc, char* argv[])
{
    size_t tests = sizeof(suite) / sizeof(unit_test_suite);
    size_t total_suites = 0;
    size_t total_tests = 0;
    size_t pass_count = 0;
    size_t fail_count = 0;

    for (size_t i = 0; i < tests; ++i, ++total_suites)
    {
        printf("%s [%zu]: ", suite[i].name, suite[i].entries);

        for (size_t j = 0; j < suite[i].entries; ++j, ++total_tests)
        {
            bool testpass = suite[i].array[j].function();
            if (testpass)
            {
                printf(".");
                ++pass_count;
            }
            else
            {
                printf("!%s ", suite[i].array[j].name);
                ++fail_count;
            }
        }

        printf("\n");
    }
>>@<<

The outer loop in \verb/main/ iterates through the test suites. The name of the
suite along with the total number of tests is output. Then, the inner loop is
run over each test. For each test, it is executed. If it passes, a single dot is
output. If it fails, then an exclamation point along with the name of the
failing test is output.  Finally, we output the test results.  If all tests
passed, then we return $0$. If any test fails, we return $1$.

#[language=c]
<<test-runner-main>>=
    printf(
        "\nRan %zu test%s in %zu suite%s: %zu test%s passed and "
        "%zu test%s failed.\n",
        total_tests, plural(total_tests), total_suites, plural(total_suites),
        pass_count, plural(pass_count), fail_count, plural(fail_count));

    if (fail_count > 0)
        return 1;
    else
        return 0;
}
>>@<<

\newpage

We make use of a helper that we call \verb/plural/ in the above tabulation. This
just makes the English read a little better.  The \verb/plural/ macro expands to
a simple ternary operator based on comparing the argument with one. If the
argument is exactly one, then the singular form is used. Otherwise, the plural
form is used.

#[language=c]
<<test-runner-helpers>>=
#define plural(val) ((val == 1) ? "" : "s")
>>@<<

The \verb/test-suite-definition/ is where the first bit of magic happens. Since
we are using minweb as our literate programming processor, we can take advantage
of minweb macros to append test suites on the fly in the rest of the document,
as we add them.  This definition sets up the possibility.  In the definition, we
define the \verb/suite/ array and reference a \verb/test-suite/ macro, which
expands to each of the entries in this array.  When we define a new test suite,
we simply append to this macro.

Prior to the test suites, we provide three more macros: \verb/test-decls/,
\verb/test-suite-decls/, and \verb/test-suite-arrays/.  These three macros will
hold the unit test declarations, the test suite array declarations, and the test
suite arrays themselves.  These all need to occur before the \verb/suite/ array
for dependency reasons.

#[language=c]
<<test-suite-definition>>=

<<test-decls>>
<<test-suite-decls>>
<<test-suite-arrays>>

unit_test_suite suite[] =
{
    <<test-suite>>
};
>>@<<

Finally, we define a macro, \verb/test-suite-arrays/, which is where we will
store the array definitions for each test suite.  These will all be loaded in
the test runner at compile time, which links everything together nicely.

We can test the test runner by creating a simple test suite and test in the
suite to verify that this mechanism works.  First, we add a new test suite,
which we call, \verb/metatest/. We need to add a declaration to the
\verb/test-suite-decls/ macro and register it in the \verb/test-suite/ macro.

#[language=c]
<<test-suite-decls>>=
TEST_SUITE_DECL(metatest)
>>@<<

#[language=c]
<<test-suite>>=
TEST_SUITE(metatest)
>>@<<

For this test suite to execute, we use the \verb/TEST_SUITE_BEGIN/ and
\verb/TEST_SUITE_END/ macros. Inside of these macros, we place a macro for
holding our unit tests.

#[language=c]
<<test-suite-arrays>>=
TEST_SUITE_BEGIN(metatest)
<<metatest-tests>>
TEST_SUITE_END()
>>@<<

<<SECTION:metatest_simple>>=
Here, we define a \verb/metatest-tests/ macro, which we can use for appending
tests to our metatest suite. For now, we will append a single unit test,
\verb/metatest_simple/. In the next section, we will concentrate on marshalling
data from our document to the unit tests, but for now, we will include a very
simple pass or fail metric.  We can do this by embedding our interaction in a
special section, as done in the source for this document. Then, we reference an
output variable. Our test is currently \colorbox{black}{%[testresult]%}.
>>@<<

#[language=c]
<<test-decls>>=
TEST_DECL(metatest_simple)
>>@<<

#[language=c]
<<metatest-tests>>=
TEST(metatest_simple)
>>@<<

We declare the unit test in \verb/test-decls/, which makes this symbol
visible to the suite. Then, we add this test to the suite by adding it to the
\verb/metatest-tests/ macro that we defined above. This ensures that the test is
executed as part of our suite.  Now, we can implement a simple test of our test
runner and testing framework.  The \verb/metatest_simple/ test writes to an
output file that is incorporated into the above paragraph. The last line of the
paragraph displays the test status. For now, we just hard code a "passing"
status and return \verb/true/ to let the test runner know that our unit test
passed. In the next section, we will improve upon this marshalling and I/O to
automate this interaction.

#[language=c]
<<FILE:test/metatest/simple.c>>=
#include <modelrunner/test.h>
#include <stdio.h>

bool metatest_simple()
{
    FILE* f = fopen("metatest_simple.output", "w");
    if (NULL == f)
    {
        return false;
    }

    fprintf(f, "testresult=\\textcolor{green}{passing}\n");
    fclose(f);
    return true;
}
>>@<<

\newpage

\subsection{Marshalling Unit Test Values}

The process of marshalling data from the document key-value pair files to a
format that we can use in the unit test cases is actually pretty
straight-forward. The biggest issue is avoiding a lot of overhead and
duplication in the test cases.  This is easily done by providing functions to do
the heavy lifting, and macros to wrap these functions.  As with higher-level
languages, we can map some implicit parameters with the macros to make life a
bit easier when writing tests.

First, we will define \verb/TEST_BEGIN/ and \verb/TEST_END/ macros. The first
macro will take one parameter: a string naming the test case. This string will
be used to construct the input and output file names.  The macro itself will
read the input file and open the output file for writing.  The \verb/TEST_END/
macro will close the output file and clean up the \verb/rbtree/ instance that we
use for storing the input values. The \verb/TEST_ASSERT/ macro returns
\verb/false/ if the assertion fails, exiting the function. Note that this means
that the macros can leak memory and resources if the tests fail. Since we are
typically working with test-driven development (TDD), there will only be a few
resources leaked at a time if a unit test should fail. This should not be a
significant concern. Finally, the \verb/TEST_END/ macro will return the running
status of the function. No code should be written after \verb/TEST_END/.

#[language=c]
<<marshalling-header>>=
#define TEST_BEGIN(test_name) \
    bool test_success = true; \
    FILE* testout; \
    RCPR_SYM(allocator)* alloc; \
    RCPR_SYM(rbtree)* dict; \
    TEST_ASSERT(0 == RCPR_SYM(malloc_allocator_create)(&alloc)); \
    TEST_ASSERT(0 == read_test_input(&dict, alloc, # test_name)); \
    TEST_ASSERT(0 == create_test_output(&testout, # test_name))

#define TEST_END() \
    TEST_ASSERT( \
        STATUS_SUCCESS == \
            RCPR_SYM(resource_release)( \
                RCPR_SYM(rbtree_resource_handle)(dict))); \
    TEST_ASSERT(0 == fclose(testout)); \
    TEST_ASSERT( \
        STATUS_SUCCESS == \
            RCPR_SYM(resource_release)( \
                RCPR_SYM(allocator_resource_handle)(alloc))); \
    return test_success

#define TEST_ASSERT(cond) \
    if (!(cond)) \
    { \
        fclose(testout); \
        return false; \
    } \
    do { } while (0)

#define TEST_FAILURE(cond) \
    test_success = false
>>@<<

We also need to define \verb/read_test_input/ and \verb/create_test_output/. We
will start with the declarations. The \verb/read_test_input/ function takes a
pointer to a \verb/rbtree/ pointer and a character string as input. On success,
it initializes the \verb/dict/ pointer pointer to a \verb/rbtree/ instance that
has each of the key-value pairs found in the \verb/.input/ file.  The
\verb/create_test_output/ function creates the \verb/.output/ file associated
with the \verb/test_name/ parameter and saves it to the \verb/FILE/ pointer
pointer in the first parameter.  Both functions return $0$ on success and
non-zero on failure.

#[language=c]
<<marshalling-header>>=
int read_test_input(
    RCPR_SYM(rbtree)** dict, RCPR_SYM(allocator)* alloc, const char* test_name);
int create_test_output(FILE** fp, const char* test_name);
>>@<<

\newpage

We need methods to initialize values based on keys. To keep things simple, and
to handle tests with multiple values, we will always use an offset integer value
to represent which value tuple we wish to access.  Thus, we can create functions
to marshall in data for strings, characters, and integers.  We don't provide an
exhaustive list of primitive types; for instance, we don't really care about
floating point values in this tool.  Likewise, we provide \verb/uint64_t/ and
\verb/int64_t/. Application code can map to smaller numerical values if desired.
The string version of these methods just map a constant string from the
underlying \verb/rbtree/ instance. Thus, we don't have to worry about memory
management.  Here are the declarations for each of the init methods.  They take
four parameters: the output variable pointer, the rbtree instance, the key, and
the numerical offset.  So, for instance, the key \verb/actor/ and the offset $2$
would map to the key \verb/actor2/ in the input file / \verb/rbtree/.

#[language=c]
<<marshalling-header>>=
bool read_test_string(
    const char** var, RCPR_SYM(rbtree)* dict, const char* key, int offset);
bool read_test_int(
    int64_t* var, RCPR_SYM(rbtree)* dict, const char* key, int offset);
bool read_test_uint(
    uint64_t* var, RCPR_SYM(rbtree)* dict, const char* key, int offset);
>>@<<

We can use the \verb/TEST_ASSERT/ macro to fail a test if a given read fails. If
we want to exit a test successfully if a given read fails, we can use the
\verb/TEST_TRY/ macro below.  In this case, when reading a tuple, the first
value read should be read with a \verb/TEST_TRY/, and each subsequent value
should be read with a \verb/TEST_ASSERT/. Note that if a previous iteration
failed with \verb/TEST_FAILURE/, then \verb/TEST_TRY/ will return \verb/false/.

#[language=c]
<<marshalling-header>>=
#define TEST_TRY(cond) \
    if (!(cond)) \
    { \
        fclose(testout); \
        return test_success; \
    } \
    do { } while (0)
>>@<<

We can now look at the implementation of \verb/test_read_input/. We begin this
method by creating the name of the input file based on the name of the test.
Then, we create the \verb/rbtree/ instance. Then, we open the input file.
Finally, we decode each line and add these to the \verb/rbtree/. If everything
goes to plan, we save the rbtree instance and then do our cleanup. If something
should fail in these steps, then we will jump to the correct cleanup spot to
ensure that any resource owned by this function is cleaned up before we return
to the caller.

#[language=c]
<<FILE:src/testharness/read_test_input.c>>=
#include <modelrunner/test.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

<<rcpr-imports>>

int read_test_input(rbtree** dict, allocator* alloc, const char* test_name)
{
    <<read-test-input-variables>>
    <<read-test-input-create-input-filename>>
    <<read-test-input-create-rbtree>>
    <<read-test-input-open-file>>
    <<read-test-input-decode-lines>>
    <<read-test-input-save>>

    <<read-test-input-cleanup-file>>
    <<read-test-input-cleanup-rbtree>>

done:
    return retval;
}
>>@<<

The rcpr-imports macro is used repeatedly. This is boilerplate that we can
deduplicate here.

<<rcpr-imports>>=
RCPR_IMPORT_allocator;
RCPR_IMPORT_compare;
RCPR_IMPORT_rbtree;
RCPR_IMPORT_resource;
>>@<<

We use the following variables in this method. The \verb/filename/ variable
holds the computed filename.  Then, \verb/line/ and \verb/line_size/ are used
for reading lines from the input file. The \verb/key/ and \verb/value/ variables
are used to split the line into a key and value pair.  The \verb/retval/ and
\verb/release_retval/ variables are used for determining whether functions
called by this function succeed or fail. The \verb/tmp/ \verb/rbtree/ pointer is
used to store the \verb/rbtree/ we create until we can determine whether we
should destroy this instance due to an error or return it to the caller. The
\verb/f/ variable holds our input file. Then \verb/pair/ is used for each pair
that we create, and \verb/i/ is used during our scan for an equal sign.

#[language=c]
<<read-test-input-variables>>=
    char filename[1024];
    char* line = NULL;
    size_t line_size = 0;
    char key[1024];
    char value[8192];
    int retval, release_retval;
    rbtree* tmp = NULL;
    FILE* f;
    read_test_input_pair* pair;
    size_t i;
>>@<<

To create the input filename, we use \verb/snprintf/ to format a string with
the input test name and the \verb/.input/ extension.  This could fail if the
user provides an extra-long test name. So, we verify that the number of bytes
that would have been written. This must be less than the size of the
\verb/filename/ variable, to account for the final \verb/NULL/ byte. If it is
not, an error is returned to the user.

#[language=c]
<<read-test-input-create-input-filename>>=
    size_t print_size =
        snprintf(filename, sizeof(filename), "%s.input", test_name);
    if (print_size >= sizeof(filename))
    {
        retval = 1;
        goto done;
    }
>>@<<

To create the \verb/rbtree/ instance, we call \verb/rbtree_create/, passing it
the address of our temporary \verb/rbtree/ pointer, our \verb/allocator/, a
comparison function and a function to get the key from our value inserted into
the \verb/rbtree/.

#[language=c]
<<read-test-input-create-rbtree>>=
    retval =
        rbtree_create(
            &tmp, alloc, &test_input_dict_compare, &test_input_dict_key, NULL);
    if (STATUS_SUCCESS != retval)
    {
        goto done;
    }
>>@<<

We will revisit the comparison and key functions in a moment.  For now, we will
just add them to our header.

#[language=c]
<<marshalling-header>>=
RCPR_SYM(rcpr_comparison_result) test_input_dict_compare(
    void* context, const void* lhs, const void* rhs);
const void* test_input_dict_key(
    void* context, const RCPR_SYM(resource)* r);
>>@<<

If something should go wrong during our subsequent operations, we need to clean
up the \verb/rbtree/ instance. We do this using the label,
\verb/cleanup_rbtree/. We make use of a special return value that is separate
from our \verb/retval/ variable to check the return from cleaning up the
resource. If this cleanup should fail, we still want to go through with the
remaining cleanup steps, but we want to make sure that an error is returned to
the caller. In this case, the original error code is replaced with the error
code we got from this cleanup. When we want to return this rbtree to the user,
we will set \verb/tmp/ to \verb/NULL/.  This will bypass the cleanup.

<<read-test-input-cleanup-rbtree>>=
cleanup_rbtree:
    if (NULL != tmp)
    {
        release_retval = resource_release(rbtree_resource_handle(tmp));
        if (STATUS_SUCCESS != release_retval)
        {
            retval = release_retval;
        }
    }
>>@<<

Next, we open the input file. If this should fail, then we will clean up the
\verb/rbtree/ instance, using our \verb/cleanup_rbtree/ label, and return to the
caller.

#[language=c]
<<read-test-input-open-file>>=
    f = fopen(filename, "r");
    if (NULL == f)
    {
        retval = 1;
        goto cleanup_rbtree;
    }
>>@<<

To clean up the input file handle, we can jump to the \verb/cleanup_file/
handle. This just calls \verb/fclose/ on the file handle. This label is ordered
so that \verb/cleanup_rbtree/ happens after this cleanup step, so we can cascade
cleanup steps.

#[language=c]
<<read-test-input-cleanup-file>>=
cleanup_file:
    fclose(f);
>>@<<

To decode each line, we first read it into the line buffer. Then, we scan for an
equal sign. Everything to the left of the equal sign is copied to the key
buffer, and everything to the right of the equal sign is copied into the value
buffer. We use \verb/strlcpy/ to ensure that the resulting buffers are NULL
terminated. While we don't expect to see values in excess of 8 kilobytes, we
will truncate both the key and the value to 1 kilobyte and 8 kilobytes in size,
respectively.

We start this loop by reading the input line using \verb/getline/. The
\verb/getline/ function allocates memory for the line and sets the last
character of the line to the delimiter character. We fix this up by taking the
line length, comparing the last character to the delimiter, and ``chomping`` it
if it is the delimiter.

#[language=c]
<<read-test-input-decode-lines>>=
    while (!feof(f))
    {
        if (getline(&line, &line_size, f) < 0)
        {
            break;
        }

        size_t linelen = strlen(line);
        if (line[linelen - 1] == '\n')
        {
            line[linelen-1] = 0;
            linelen -= 1;
        }
>>@<<

\newpage

Next, we scan for the first equal sign, which is the delimiter between the key
and value. If the scan is unsuccessful, this is a malformed line, and an error
is set. We perform cleanup and exit.  If the delimiter would make the key or the
value too large, then this is an error, and we perform cleanup and exit.
Otherwise, we \verb/NULL/ out the delimiter, then copy the left-hand side to the
key buffer and copy the right-hand side to the value buffer. Once the values are
copied, we no longer need \verb/line/ and can free it.

#[language=c]
<<read-test-input-decode-lines>>=
        for (i = 0; i < linelen; ++i)
            if (line[i] == '=')
                break;

        if (i >= linelen)
        {
            free(line);
            retval = 2;
            goto cleanup_file;
        }

        if (i > (sizeof(key)) || (linelen - i) > (sizeof(value) - 1))
        {
            free(line);
            retval = 3;
            goto cleanup_file;
        }

        line[i] = 0;
        strlcpy(key, line, sizeof(key));
        strlcpy(value, line + i + 1, sizeof(value));
        free(line);
        line = NULL;
        line_size = 0;
>>@<<

With the key and the value set, we create a resource to hold this key-value pair
and insert this resource into the \verb/rbtree/ instance. We use the helper
function, \verb/read_test_input_pair_create/ to create this pair from the key
and value.  The resource release method for this pair, called
\verb/read_test_input_pair_resource_release/, will take care of cleaning up this
data. Once the pair is created, we can insert it into our \verb/rbtree/. If the
insert fails, we clean up the pair's resource handle, and return. If the insert
succeeds, the \verb/rbtree/ instance takes ownership of this pair. Thus
completes one iteration of this loop. The loop will continue until the end of
the input file is reached.

#[language=c]
<<read-test-input-decode-lines>>=
        retval = read_test_input_pair_create(&pair, alloc, key, value);
        if (STATUS_SUCCESS != retval)
        {
            goto cleanup_file;
        }

        retval = rbtree_insert(tmp, &pair->hdr);
        if (STATUS_SUCCESS != retval)
        {
            release_retval = resource_release(&pair->hdr);
            if (STATUS_SUCCESS != release_retval)
            {
                retval = release_retval;
            }

            goto cleanup_file;
        }
    }
>>@<<

\newpage

Once the loop completes successfully, the \verb/rbtree/ instance is returned to
the caller by setting \verb/dict/ to this tree. The \verb/tmp/ variable is set
to \verb/NULL/ since the caller takes ownership of the tree on success. Then, we
can set the return value to \verb/STATUS_SUCCESS/ and do any last bit of cleanup
before returning to the caller.

#[language=c]
<<read-test-input-save>>=
    *dict = tmp;
    tmp = NULL;
    retval = STATUS_SUCCESS;
    goto cleanup_file;
>>@<<

We need to add the input pair create and resource management methods to the
marshalling header. The key pair structure is a \verb/resource/ that holds a
reference to the \verb/allocator/, needed for cleanup, and a pointer to the key
and value. The \verb/read_test_input_pair_create/ method creates an instance of
this pair. The \verb/read_test_input_pair_resource_release/ method is registered
with the pair \verb/resource/ so it can be used to release this resource when
\verb/resource_release/ is called on it. This method will clean up the heap
allocated memory associated with the key and value.

#[language=c]
<<marshalling-header>>=
typedef struct read_test_input_pair read_test_input_pair;
struct read_test_input_pair
{
    RCPR_SYM(resource) hdr;
    RCPR_SYM(allocator)* alloc;
    const char* key;
    const char* value;
};

status read_test_input_pair_create(
    read_test_input_pair** pair, RCPR_SYM(allocator)* alloc, const char* key,
    const char* value);
status read_test_input_pair_resource_release(RCPR_SYM(resource)* r);
>>@<<

The pair creation method allocates memory to hold the pair.

#[language=c]
<<FILE:src/testharness/read_test_input_pair_create.c>>=
#include <modelrunner/test.h>
#include <rcpr/allocator.h>
#include <string.h>

<<rcpr-imports>>

status read_test_input_pair_create(
    read_test_input_pair** pair, RCPR_SYM(allocator)* alloc, const char* key,
    const char* value)
{
    read_test_input_pair* tmp = NULL;
    status retval, release_retval;

    retval = allocator_allocate(alloc, (void**)&tmp, sizeof(*tmp));
    if (STATUS_SUCCESS != retval)
    {
        goto done;
    }
>>@<<

Next, the allocated memory is cleared and the resource handle is set up as a
\verb/resource/.  This associates the resource release method for the pair with
the resource handle.

#[language=c]
<<FILE:src/testharness/read_test_input_pair_create.c>>=
    memset(tmp, 0, sizeof(*tmp));
    resource_init(&tmp->hdr, &read_test_input_pair_resource_release);
>>@<<

Next, the allocator is saved.  The key and value variables are duplicated onto
the heap. These duplicate pointers are saved in the pair. If either of the
string duplications fail, then the structure is cleaned up by releasing it, and
this function returns an error code.

#[language=c]
<<FILE:src/testharness/read_test_input_pair_create.c>>=
    tmp->alloc = alloc;
    tmp->key = strdup(key);
    tmp->value = strdup(value);
    if (NULL == tmp->key || NULL == tmp->value)
    {
        retval = 1;
        goto cleanup_tmp;
    }
>>@<<

Finally, if everything was set up successfully, the pair variable is updated
with this newly created pair, and \verb/STATUS_SUCCESS/ is returned to the
caller.

#[language=c]
<<FILE:src/testharness/read_test_input_pair_create.c>>=
    *pair = tmp;
    retval = STATUS_SUCCESS;
    goto done;
>>@<<

If something does fail, the \verb/cleanup_tmp/ label is jumped to, which does
the resource release on this pair. Our resource release function knows how to
deal with partially constructed resources, so this exit point works no matter
which part fails.  This cleanup falls through into the \verb/done/ label, which
is jumped to directly if either an error occurs in allocation or if this
function exits successfully.

#[language=c]
<<FILE:src/testharness/read_test_input_pair_create.c>>=
cleanup_tmp:
    release_retval = resource_release(&tmp->hdr);
    if (STATUS_SUCCESS != release_retval)
    {
        retval = release_retval;
    }

done:
    return retval;
}
>>@<<

\newpage

Next, we can describe \verb/read_test_input_pair_resource_release/. This
function takes a \verb/resource/ associated with the pair, casts it back to the
pair, then frees memory associated with the key and value (if they are set). It
then releases the memory associated with the pair itself.

#[language=c]
<<FILE:src/testharness/read_test_input_pair_resource_release.c>>=
#include <modelrunner/test.h>
#include <stdlib.h>

<<rcpr-imports>>

status read_test_input_pair_resource_release(resource* r)
{
    read_test_input_pair* pair = (read_test_input_pair*)r;

    allocator* alloc = pair->alloc;

    if (NULL != pair->key)
    {
        free((void*)pair->key);
    }

    if (NULL != pair->value)
    {
        free((void*)pair->value);
    }

    return allocator_reclaim(alloc, pair);
}
>>@<<

In order to organize the \verb/rbtree/ instance, we need to define both a key
comparison and a key extraction method. The key comparison method is
\verb/test_input_dict_compare/. This method takes an optional context, a
left-hand side and a right-hand side for the comparison. We will be comparing
strings, since our keys are strings. So, we can implement this comparison
function in terms of \verb/strcmp/. This function performs a lexicographical
comparison between two strings. It returns the result of this comparison. If the
result is less than zero, then the left-hand string is less than the right-hand
string.  If the result is greater than zero, then the left-hand string is
greater than the right-hand string. If the result is zero, both strings are
equal.

#[language=c]
<<FILE:src/testharness/test_input_dict_compare.c>>=
#include <modelrunner/test.h>
#include <string.h>

<<rcpr-imports>>

rcpr_comparison_result test_input_dict_compare(
    void* context, const void* lhs, const void* rhs)
{
    const char* left = (const char*)lhs;
    const char* right = (const char*)rhs;

    int retval = strcmp(left, right);

    if (retval < 0)
        return RCPR_COMPARE_LT;
    else if (retval > 0)
        return RCPR_COMPARE_GT;
    else
        return RCPR_COMPARE_EQ;
}
>>@<<

\newpage

The key extraction method is \verb/test_input_dict_key/. This method takes an
optional context and a \verb/resource/ pointer to the value stored in the
\verb/rbtree/.  In this case, the resource pointer is our pair.  We extract the
key from this pair, and return it as a type erased pointer.

#[language=c]
<<FILE:src/testharness/test_input_dict_key.c>>=
#include <modelrunner/test.h>

<<rcpr-imports>>

const void* test_input_dict_key(
    void* context, const resource* r)
{
    const read_test_input_pair* pair = (const read_test_input_pair*)r;

    return pair->key;
}
>>@<<

The \verb/create_test_output/ function opens an output file for storing the
variable results from a given test case.  As with \verb/read_test_input/, it
creates a filename, in this case, an \verb/.output/ filename, based on the test
name. As before, we need to check the return value of \verb/snprintf/ to ensure
that the entire test name was written to the filename. This must be less than
the size of the \verb/filename/ variable, to account for the final \verb/NULL/
byte. If it is not, then an error is returned to the user.

The file is opened for writing. If this step fails, then \verb/fopen/ returns
\verb/NULL/, and we return an error code to the caller.  Otherwise, we can exit
successfully.

#[language=c]
<<FILE:src/testharness/create_test_output.c>>=
#include <modelrunner/test.h>

int create_test_output(FILE** fp, const char* test_name)
{
    char filename[1024];

    size_t print_size =
        snprintf(filename, sizeof(filename), "%s.output", test_name);
    if (print_size >= sizeof(filename))
    {
        return 1;
    }

    *fp = fopen(filename, "w");
    if (NULL == *fp)
    {
        return 1;
    }

    return 0;
}
>>@<<

\newpage

To read values into the test case, we have \verb/read_test_string/,
\verb/read_test_int/, and \verb/read_test_uint/. We will build macros to
simplify the usage of these in a moment, but for now, we can focus on
implementing these functions. We can implement the latter two functions in terms
of the first function. The first thing we do is create a key that includes the
offset value. This uses \verb/snprintf/, and as before, we must verify the
output of \verb/snprintf/ to ensure that the value was not truncated. We then
use this key to attempt to find a resource via \verb/rbtree_find/. If the find
fails, or the \verb/resource/ is \verb/NULL/, then the lookup fails. Otherwise,
we extract the value from the resource. If this value is NULL, then the lookup
fails.  Otherwise, we return the value to the caller.

#[language=c]
<<FILE:src/testharness/read_test_string.c>>=
#include <modelrunner/test.h>

<<rcpr-imports>>

bool read_test_string(
    const char** var, rbtree* dict, const char* key, int offset)
{
    read_test_input_pair* pair;
    char xkey[1024];
    status retval;

    size_t print_size = snprintf(xkey, sizeof(xkey), "%s%d", key, offset);
    if (print_size >= sizeof(xkey))
    {
        return false;
    }

    retval = rbtree_find((resource**)&pair, dict, xkey);
    if (STATUS_SUCCESS != retval)
    {
        return false;
    }

    if (NULL == pair || NULL == pair->value)
    {
        return false;
    }

    *var = pair->value;
    return true;
}
>>@<<

\newpage

We can write \verb/read_test_int/ in terms of \verb/read_test_string/. We use
\verb/strtoll/ to convert the string representation of the value to an
\verb/int64_t/ value. Since this is for testing, we don't do much checking on
this input value. If you send garbage input to the test, expect garbage output.
We cast this value to \verb/int64_t/, since on some platforms, it's possible
that \verb/long long/ is bigger.

#[language=c]
<<FILE:src/testharness/read_test_int.c>>=
#include <modelrunner/test.h>
#include <stdlib.h>

<<rcpr-imports>>

bool read_test_int(int64_t* var, rbtree* dict, const char* key, int offset)
{
    const char* val = NULL;
    long long ival;

    if (!read_test_string(&val, dict, key, offset))
    {
        return false;
    }

    ival = strtoll(val, NULL, 10);
    *var = (int64_t)ival;
    return true;
}
>>@<<

Finally, \verb/read_test_uint/ works almost exactly like \verb/read_test_int/,
except that it uses \verb/strtoull/, which returns the unsigned representation
of a given string. Note that this function can still process negative numbers;
it just returns the unsigned representation of this negative number. Again,
these methods aren't meant to police input data for unit tests. Garbage in /
garbage out.

#[language=c]
<<FILE:src/testharness/read_test_uint.c>>=
#include <modelrunner/test.h>
#include <stdlib.h>

<<rcpr-imports>>

bool read_test_uint(uint64_t* var, rbtree* dict, const char* key, int offset)
{
    const char* val = NULL;
    unsigned long long uval;

    if (!read_test_string(&val, dict, key, offset))
    {
        return false;
    }

    uval = strtoll(val, NULL, 10);
    *var = (uint64_t)uval;
    return true;
}
>>@<<

\newpage

There is no reason to extend the cognitive load of the file pointer and
dictionary to the user. We can make these arguments implicit by writing some
macros that plug in the missing arguments. We will call these macros
\verb/READ_STRING/, \verb/READ_INT/, and \verb/READ_UINT/.

#[language=c]
<<marshalling-header>>=
#define READ_STRING(var, key, offset) \
    read_test_string((var), dict, (key), (offset))
#define READ_INT(var, key, offset) \
    read_test_int((var), dict, (key), (offset))
#define READ_UINT(var, key, offset) \
    read_test_uint((var), dict, (key), (offset))
>>@<<

Likewise, we can create the write equivalents to these macros. In each, we use
\verb/fprintf/ to write the key, offset, and value.

#[language=c]
<<marshalling-header>>=
#define WRITE_STRING(val, key, offset) \
    fprintf(testout, "%s%d=%s\n", key, offset, val)
#define WRITE_INT(val, key, offset) \
    fprintf(testout, "%s%d=%lld\n", key, offset, val)
#define WRITE_UINT(val, key, offset) \
    fprintf(testout, "%s%d=%llu\n", key, offset, val)
>>@<<

In a lot of cases, we actually want to write the value to the output file
immediately after reading it.  So, we create some helper read / write macros.

#[language=c]
<<marshalling-header>>=
#define READ_WRITE_STRING(var, key, offset) \
    (READ_STRING(var, key, offset) ? WRITE_STRING(*(var), key, offset) : false)
#define READ_WRITE_INT(var, key, offset) \
    (READ_INT(var, key, offset) ? WRITE_INT(*(var), key, offset) : false)
#define READ_WRITE_UINT(var, key, offset) \
    (READ_UINT(var, key, offset) ? WRITE_UINT(*(var), key, offset) : false)
>>@<<

Finally, we may want to provide a success or failure indication to our test
documentation. For this, two macros, \verb/WRITE_SUCCESS/ and
\verb/WRITE_FAILURE/ can be used. They output a \LaTeX formatted string with
text color.  We use red for failure and green for success.

#[language=c]
<<marshalling-header>>=
#define WRITE_SUCCESS(key, offset) \
    fprintf(testout, "%s%d=\\textcolor{green}{success}\n", key, offset);
#define WRITE_FAILURE(key, offset) \
    fprintf(testout, "%s%d=\\textcolor{red}{failure}\n", key, offset);
>>@<<

In the next section, we will put all of this together into an embedded unit
test.

\newpage

\subsection{Example Unit Test}

We will extend the metatest suite with one more unit test case, which will
attempt to verify the given truth table for the exclusive or operator.

<<SECTION:metatest_example>>=
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
$x$        & $y$        & $x$ xor $y$         & result        & status \\
\hline
$%[x0=0]%$ & $%[y0=0]%$ & $%[expected0=0]%$   & $%[result0]%$ & %[status0]% \\
\hline
$%[x1=0]%$ & $%[y1=1]%$ & $%[expected1=1]%$   & $%[result1]%$ & %[status1]% \\
\hline
$%[x2=1]%$ & $%[y2=0]%$ & $%[expected2=1]%$   & $%[result2]%$ & %[status2]% \\
\hline
$%[x3=1]%$ & $%[y3=1]%$ & $%[expected3=0]%$   & $%[result3]%$ & %[status3]% \\
\hline
\end{tabular}
\end{center}
>>@<<

To create our new test, we add it to our test declarations and register it to
the metatest suite.

#[language=c]
<<test-decls>>=
TEST_DECL(metatest_example)
>>@<<

#[language=c]
<<metatest-tests>>=
TEST(metatest_example)
>>@<<

We can now create our unit test. Here, we make use of \verb/TEST_BEGIN/,
\verb/TEST_END/, \verb/READ_INT/, \verb/WRITE_INT/, \verb/WRITE_SUCCESS/, and
\verb/WRITE_FAILURE/.  The results will appear in the above table.

#[language=c]
<<FILE:test/metatest/example.c>>=
#include <modelrunner/test.h>

<<rcpr-imports>>

bool metatest_example()
{
    int offset = 0;
    int64_t x;
    int64_t y;
    int64_t expected;
    int64_t result;

    TEST_BEGIN(metatest_example);
        for(;;++offset)
        {
            TEST_TRY(READ_WRITE_INT(&x, "x", offset));
            TEST_ASSERT(READ_WRITE_INT(&y, "y", offset));
            TEST_ASSERT(READ_WRITE_INT(&expected, "expected", offset));
            result = x ^ y;
            WRITE_INT(result, "result", offset);
            if (result == expected)
            {
                WRITE_SUCCESS("status", offset);
            }
            else
            {
                WRITE_FAILURE("status", offset);
                TEST_FAILURE();
            }
        }
    TEST_END();
}
>>@<<
